---
title: "Tareas segundo corte"
author: "Juan Pablo Gómez Morales"
date: "2025-11-14"
output: html_document
---

#######################################################

Método de la bisección:

```{r}
# Teorema del valor intermedio (método de la bisección)

# Definimos una función
fun <- function(x) {
  funct<- exp(x) - sin(x)
  return(funct)
}


algoritm <- function(a, b, fun, error) {
  if (a>b){
    print("Los intervalos no están bien definidos")
  }
  else {
    curve(fun, from = a, to = b, col = "blue", lwd = 2,
          xlab = "Eje X", ylab = "Eje Y", main = "Gráfico de la función")
  while (fun(a) * fun(b) < 0) {
    len <- b-a
    c<- b-len/2
    if(abs(fun(c))<error){
      break
    }
    else if(fun(a) * fun(c) < 0) {
      b <- c
    } else if (fun(b) * fun(c) <0) {
      a <- c
    }}
    points(c, fun(c), col = "red", pch = 19, cex = 2) # Punto rojo, tamaño 2
  }
  return(c)
}
 
algoritm(-10,0, fun,  10**(-5))  
```

```{r}
ffun <- function(x) {
  funct<- abs(x)-cos(x)
  return(funct)
}

algoritm(2, 1, ffun, 10**(-5))
```

#######################################################


Método de la secante:

```{r}
metodo_secante <- function(f, x0, x1, tol = 1e-8, max_iter = 100) {
  # Verificar que los puntos iniciales son diferentes
  if (x0 == x1) {
    stop("Los puntos iniciales x0 y x1 deben ser diferentes.")
  }
  
  iter <- 0
  x_actual <- x1
  x_anterior <- x0
  
  # Vector para almacenar las aproximaciones en cada iteración
  aproximaciones <- numeric(max_iter + 2)
  aproximaciones[1] <- x0
  aproximaciones[2] <- x1
  
  while (iter < max_iter) {
    # Calcular f(x) en los puntos actual y anterior
    f_actual <- f(x_actual)
    f_anterior <- f(x_anterior)
    
    # Verificar división por cero
    if (f_actual - f_anterior == 0) {
      warning("División por cero. El método puede no converger.")
      break
    }
    
    # Fórmula del método de la secante
    x_nuevo <- x_actual - f_actual * (x_actual - x_anterior) / (f_actual - f_anterior)
    
    # Almacenar la nueva aproximación
    aproximaciones[iter + 3] <- x_nuevo
    
    # Verificar convergencia
    if (abs(x_nuevo - x_actual) < tol) {
      break
    }
    
    # Actualizar los puntos para la siguiente iteración
    x_anterior <- x_actual
    x_actual <- x_nuevo
    iter <- iter + 1
  }
  
  # Preparar resultados
  resultados <- list(
    raiz = x_actual,
    iteraciones = iter + 1,
    error_est = abs(x_actual - x_anterior),
    historial = aproximaciones[1:(iter + 2)],
    f_raiz = f(x_actual)
  )
  
  return(resultados)
}

# Ejemplo de uso 1: Función cuadrática
f1 <- function(x) {
  x^2 - 4
}

# Ejemplo de uso 2: Función trigonométrica
f2 <- function(x) {
  cos(x) - x
}

# Ejemplo de uso 3: Función exponencial
f3 <- function(x) {
  exp(x) - 3*x
}

# Probar con la primera función
cat("Método de la Secante\n")
cat("Función: f(x) = x^2 - 4\n")
resultado1 <- metodo_secante(f1, 1, 3)
print(paste("Raíz aproximada:", resultado1$raiz))
print(paste("Iteraciones:", resultado1$iteraciones))
print(paste("Error estimado:", resultado1$error_est))
print(paste("f(raíz) =", resultado1$f_raiz))

# Probar con la segunda función
cat("\nFunción: f(x) = cos(x) - x\n")
resultado2 <- metodo_secante(f2, 0, 1)
print(paste("Raíz aproximada:", resultado2$raiz))
print(paste("Iteraciones:", resultado2$iteraciones))
print(paste("Error estimado:", resultado2$error_est))
print(paste("f(raíz) =", resultado2$f_raiz))

# Función para visualizar la convergencia
visualizar_convergencia <- function(resultado, funcion, titulo = "Convergencia del Método de la Secante") {
  x_vals <- seq(min(resultado$historial) - 0.5, max(resultado$historial) + 0.5, length.out = 100)
  y_vals <- funcion(x_vals)
  
  plot(x_vals, y_vals, type = "l", main = titulo, 
       xlab = "x", ylab = "f(x)", col = "blue", lwd = 2)
  abline(h = 0, col = "gray", lty = 2)
  points(resultado$historial, funcion(resultado$historial), 
         col = "red", pch = 19, cex = 0.8)
  lines(resultado$historial, funcion(resultado$historial), 
        col = "red", lty = 3)
  legend("topright", 
         legend = c("Función", "Aproximaciones", "Raíz final"),
         col = c("blue", "red", "red"),
         lty = c(1, 3, NA), pch = c(NA, NA, 19))
}

# Visualizar la convergencia para el primer ejemplo
visualizar_convergencia(resultado1, f1, "Convergencia para f(x) = x² - 4")

```


#######################################################

Método de Newton

```{r}
# Definimos la función y su derivada (hagamos por ejemplo para f(x) = x^2 - 10)
f <- function(x) {
  x^2 - 10
}

f_derivada <- function(x) {
  2*x
}

# Implementemos el método de Newton
metodo_new <- function(f, f_derivada, x0, tole = 1e-6, max_iter = 100) {
  x <- x0
  for (i in 1:max_iter) {
    # Calculemos el siguiente valor de x en la iteración
    x_new <- x - f(x) / f_derivada(x)

    # Comprobemos la condición de convergencia
    if (abs(x_new - x) < tole) {
      return(x_new) # Devolvamos la raíz encontrada
    }
    x <- x_new
  }
  warning("El método no convergió después de ", max_iter, " iteraciones.")
  return(x) # Devolvamos la última aproximación obtenida si no converge
}

# Aplicación al ejemplo
valor_inicial <- 1.0
raiz <- metodo_new(f, f_derivada, valor_inicial)
print(paste("La raíz aproximada es:", raiz))

```

##########################################

Método de Horner

```{r}
m=4 #grado del polinomio
x0=2 # valor donde queremos evaluar.
A=c(20,51,14,-15,2)#Coeficientes del polinomio en orden creciente
# iniciando con el término independiente.
p=A
if (length(A)!=m+1){"ERROR, el vector de coeficientes no coincide
con el grado del polinomio"} else
for (n in 1:(m+1)){ p[n] = (A[n])*(x0^(n-1))
}
sum(p) #resultado de la evaluación.
#Con estos valores verificamos que el algoritmo anterior sea el correcto!
#p
B=c(2^0,2^1,2^2,2^3,2^4)
sum(A*B)
```

```{r}
m=4 #grado del polinomio
x0=1 # valor donde queremos evaluar.
A=c(20,51,14,-15,2) #Coeficientes del polinomio en orden creciente iniciando con el término independiente.
Q=c(0,0,0,0,0)
if (length(A)!=m+1){"ERROR, el vector de coeficientes no coincide
con el grado del polinomio"} else
Q[m+1]=A[m+1]
for (n in 1:(m)){
Q[m+1-n] = A[m+1-n]+Q[m+2-n]*x0
}
Q[1] #resultado de la evaluación.
```

```{r}
metodo_horner <- function(coeficientes, x) {
  # Método de Horner para evaluar un polinomio y realizar división sintética
  # coeficientes: vector de coeficientes del polinomio en orden descendente
  # x: valor en el que se evalúa el polinomio
  
  n <- length(coeficientes)
  
  # Inicializar el resultado y el vector para los coeficientes del cociente
  resultado <- coeficientes[1]
  cociente <- numeric(n)
  cociente[1] <- coeficientes[1]
  
  # Aplicar el esquema de Horner
  for (i in 2:n) {
    resultado <- resultado * x + coeficientes[i]
    if (i < n) {
      cociente[i] <- resultado
    }
  }
  
  # El último elemento del cociente es el residuo
  residuo <- resultado
  
  # Preparar resultados
  list(
    valor_polinomio = resultado,
    cociente = cociente[1:(n-1)],
    residuo = residuo
  )
}

# Función para evaluar múltiples puntos usando Horner
horner_multiple <- function(coeficientes, valores_x) {
  resultados <- sapply(valores_x, function(x) {
    metodo_horner(coeficientes, x)$valor_polinomio
  })
  return(resultados)
}

# Función para encontrar una raíz usando el método de Newton-Horner
newton_horner <- function(coeficientes, x0, tol = 1e-8, max_iter = 100) {
  # Encontrar una raíz usando el método de Newton con evaluación eficiente mediante Horner
  
  iter <- 0
  x_actual <- x0
  
  while (iter < max_iter) {
    # Evaluar P(x) y P'(x) usando Horner
    eval_p <- metodo_horner(coeficientes, x_actual)
    valor_p <- eval_p$valor_polinomio
    
    # Para P'(x), usamos el cociente de la primera división
    eval_derivada <- metodo_horner(eval_p$cociente, x_actual)
    valor_derivada <- eval_derivada$valor_polinomio
    
    if (abs(valor_derivada) < tol) {
      warning("Derivada cercana a cero. El método puede no converger.")
      break
    }
    
    # Método de Newton: x_nuevo = x_actual - P(x)/P'(x)
    x_nuevo <- x_actual - valor_p / valor_derivada
    
    if (abs(x_nuevo - x_actual) < tol) {
      break
    }
    
    x_actual <- x_nuevo
    iter <- iter + 1
  }
  
  list(
    raiz = x_actual,
    iteraciones = iter,
    valor_polinomio = metodo_horner(coeficientes, x_actual)$valor_polinomio
  )
}

# Función para deflacionar un polinomio (eliminar un factor lineal conocido)
deflacion_polinomio <- function(coeficientes, raiz) {
  # Realizar división sintética para eliminar el factor (x - raiz)
  resultado <- metodo_horner(coeficientes, raiz)
  return(resultado$cociente)
}

# EJEMPLOS DE USO

# Ejemplo 1: Evaluar un polinomio en un punto
cat("=== EJEMPLO 1: Evaluación de polinomio ===\n")
# Polinomio: 2x^3 - 4x^2 + 3x - 5
coef1 <- c(2, -4, 3, -5)
x_eval <- 2
resultado1 <- metodo_horner(coef1, x_eval)
cat("Polinomio: 2x³ - 4x² + 3x - 5\n")
cat("Evaluado en x =", x_eval, ":", resultado1$valor_polinomio, "\n")
cat("Cociente (división por x-2):", resultado1$cociente, "\n")
cat("Residuo:", resultado1$residuo, "\n\n")

# Ejemplo 2: Evaluar en múltiples puntos
cat("=== EJEMPLO 2: Evaluación en múltiples puntos ===\n")
valores <- c(-1, 0, 1, 2, 3)
resultados <- horner_multiple(coef1, valores)
cat("P(x) evaluado en", valores, ":\n")
cat(resultados, "\n\n")

# Ejemplo 3: Encontrar raíces con Newton-Horner
cat("=== EJEMPLO 3: Búsqueda de raíces con Newton-Horner ===\n")
# Polinomio: x^3 - 6x^2 + 11x - 6 = (x-1)(x-2)(x-3)
coef2 <- c(1, -6, 11, -6)
raiz1 <- newton_horner(coef2, 0.5)
raiz2 <- newton_horner(coef2, 1.5)
raiz3 <- newton_horner(coef2, 2.5)

cat("Raíz 1:", raiz1$raiz, "(iteraciones:", raiz1$iteraciones, ")\n")
cat("Raíz 2:", raiz2$raiz, "(iteraciones:", raiz2$iteraciones, ")\n")
cat("Raíz 3:", raiz3$raiz, "(iteraciones:", raiz3$iteraciones, ")\n\n")

# Ejemplo 4: Deflación de polinomio
cat("=== EJEMPLO 4: Deflación de polinomio ===\n")
# Después de encontrar una raíz, deflacionamos el polinomio
cat("Polinomio original:", coef2, "\n")
coef_deflacionado <- deflacion_polinomio(coef2, raiz1$raiz)
cat("Después de eliminar el factor (x -", raiz1$raiz, "):", coef_deflacionado, "\n")

# Verificar que el polinomio deflacionado tiene grado menor
cat("El polinomio deflacionado representa:", 
    paste(coef_deflacionado, "x^", (length(coef_deflacionado)-1):0, sep = "", collapse = " + "), "\n\n")

# Función para graficar el polinomio y sus raíces
graficar_polinomio <- function(coeficientes, x_min, x_max, raices = NULL) {
  x_vals <- seq(x_min, x_max, length.out = 1000)
  y_vals <- horner_multiple(coeficientes, x_vals)
  
  plot(x_vals, y_vals, type = "l", col = "blue", lwd = 2,
       main = "Gráfica del Polinomio",
       xlab = "x", ylab = "P(x)")
  abline(h = 0, col = "gray", lty = 2)
  
  if (!is.null(raices)) {
    points(raices, rep(0, length(raices)), 
           col = "red", pch = 19, cex = 1.5)
    text(raices, 0, labels = round(raices, 3), 
         pos = 3, col = "red")
  }
  
  grid()
}

# Graficar el polinomio del ejemplo 3 con sus raíces
graficar_polinomio(coef2, 0, 4, c(raiz1$raiz, raiz2$raiz, raiz3$raiz))
```

